#!/bin/sh

# <copyright>
#  Copyright 2001-2003 BBNT Solutions, LLC
#  under sponsorship of the Defense Advanced Research Projects Agency (DARPA).
# 
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the Cougaar Open Source License as published by
#  DARPA on the Cougaar Open Source Website (www.cougaar.org).
# 
#  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS
#  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR
#  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT
#  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT
#  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL
#  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS,
#  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
#  PERFORMANCE OF THE COUGAAR SOFTWARE.
# </copyright>

#
# transform jar
#
# run with "--help" for usage notes.
#

usage () {
  cat <<EOF
Usage:
  $0 [-v] MODULE [FILTER ..]

  -v        verbose output
  MODULE    module name (e.g. "core")
  FILTER    optional filter path(s)

Adds profiling instructions to classes in the specified
module's jar file.

If the module name matches "java*patch" then the corresponding
"java.*" package is profiled.

Examples:
  # profile all of java.util.*,
  # create new \$CIP/lib/javautilpatch.jar
  $0 javautilpatch

  # profile all of Cougaar core,
  # create new \$CIP/lib/core.jar
  $0 core

  # profile some of Cougaar planning,
  # create new \$CIP/lib/planning.jar
  $0 planning org/cougaar/planning/ldm org/cougaar/planning/plugin

  # profile everything!
  for x in io net util rmi; do $0 java${x}patch; done
  for x in \$CIP/lib/*.jar; do $0 $x; done
  for x in \$CIP/sys/*.jar; do $0 $x; done
EOF
}

if [ -z $1 ] || [ $1 = --help ]; then
  usage
  exit -1
fi

VERBOSE=
if [ $1 = -v ]; then
  VERBOSE=1
  shift 1
fi

MODULE=$1
shift 1
FILTERS=$*

if [ -z $CIP ]; then
  CIP=$COUGAAR_INSTALL_PATH
fi
if [ -z $CIP ]; then
  echo "\$COUGAAR_INSTALL_PATH not set"
  exit -1
fi

TMP=$CIP/tmp

BCEL=$CIP/sys/bcel.jar

DEPENDENCY_FILE="$CIP/build/data/default.build"

SIGN_SCRIPT="$CIP/operator/sign"

if [ ! -d $TMP ]; then
  mkdir $TMP || exit -1
fi

if [ ! -f $BCEL ]; then
  echo "BCEL-5.1 jar not found: $BCEL"
  echo "See http://jakarta.apache.org/bcel"
  exit -1
fi

get_dir () {
  NAME=$2

  if [ -z $NAME ]; then
    if [ -e $CIP/lib/$MODULE.jar ]; then
      RET=$CIP/lib
    elif [ -e $CIP/sys/$MODULE.jar ]; then
      RET=$CIP/sys
    else
      echo "Unable to find $MODULE"
      exit -1
    fi
  else
    # jdk patch
    RET=$CIP/lib
  fi

  eval "$1=\"$RET\""
}

restore_jars () {
  LINK=$DIR/$MODULE.jar
  OLD=$LINK.old
  NEW=$LINK.new
  if [ -L $LINK ]; then
    if [ -f $OLD ]; then
      # restore backup
      rm $LINK || exit -1
      if [ -f $NEW ]; then
        rm $NEW || exit -1
      fi
      ln -s $OLD $LINK || exit -1
    fi
  elif [ -f $LINK ]; then
    # make backup
    mv $LINK $OLD || exit -1
    ln -s $OLD $LINK || exit -1
  fi
}

create_jars () {
  echo "  jaring"

  NEW=$DIR/$MODULE.jar.new

  cd new/old/classes || exit -1
  jar cf $NEW * || exit -1

  # sign the jar
  if [ -x $SIGN_SCRIPT ]; then
    echo "  signing new $MODULE.jar"
    $SIGN_SCRIPT $NEW || exit -1
  fi

  # create link to our new jar
  LINK=$DIR/$MODULE.jar
  if [ -L $LINK ]; then
    rm $LINK || exit -1
  fi
  if [ ! -f $LINK ]; then
    ln -s $NEW $LINK || exit -1
  fi
}

prepare_jdk () {
  NAME=$1

  FROM=$JAVA_HOME/jre/lib/rt.jar

  if [ -d $TMP/$MODULE/old/classes ]; then
    echo "  already unzipped"
    return
  fi

  echo "  unzipping"

  # figure out overlay
  OVERLAY=
  if [ $NAME = io ]; then
    # include Cougaar's custom javaiopatch overlay
    if [ -f $DIR/$MODULE.jar.old ]; then
      OVERLAY=$DIR/$MODULE.jar.old
    elif [ -f $DIR/$MODULE.jar ]; then
      OVERLAY=$DIR/$MODULE.jar
    fi
  fi

  # unzip classes to be transformed ("old")
  cd $TMP || exit -1
  mkdir -p $MODULE/old/classes || exit -1
  cd $MODULE/old/classes || exit -1
  unzip -q $FROM $FILTERS || exit -1
  find . -type d -exec chmod 777 {} \; || exit -1
  if [ ! -z $OVERLAY ]; then
    unzip -q -o $OVERLAY "java/$NAME/*" || exit -1
  fi

  # unzip the rest ("new")
  cd $TMP || exit -1
  mkdir -p $MODULE/new/old/classes || exit -1
  cd $MODULE/new/old/classes || exit -1
  unzip -q $FROM "java/$NAME/*" || exit -1
  find . -type d -exec chmod 777 {} \; || exit -1
  if [ ! -z $OVERLAY ]; then
    unzip -q -o $OVERLAY "java/$NAME/*" || exit -1
  fi
}

prepare_cougaar () {
  FROM=$DIR/$MODULE.jar
  if [ -e $DIR/$MODULE.jar.old ]; then
    FROM=$DIR/$MODULE.jar.old
  fi

  if [ -d $TMP/$MODULE/old/classes ]; then
    echo "  already unzipped"
    return
  fi

  echo "  unzipping"

  # unzip classes to be transformed ("old")
  cd $TMP || exit -1
  mkdir -p $MODULE/old/classes || exit -1
  cd $MODULE/old/classes || exit -1
  unzip -q $FROM $FILTERS || exit -1
  find . -type d -exec chmod 777 {} \; || exit -1

  # unzip the rest ("new")
  #
  # do this even if $FILTERS is empty, since the jar may contain
  # required "resource bundle" files
  cd $TMP || exit -1
  mkdir -p $MODULE/new/old/classes || exit -1
  cd $MODULE/new/old/classes || exit -1
  unzip -q $FROM || exit -1
  find . -type d -exec chmod 777 {} \; || exit -1

  # remove the jar signatures, since we're changing the classes
  #
  # our $SIGN_SCRIPT will re-sign the jar
  if [ -d META-INF ]; then
    cd META-INF || exit -1
    rm -f MANIFEST.MF PRIVILEG.DSA PRIVILEG.SF || exit -1
    if [ $MODULE = bootstrap ]; then
      rm -f BOOTSTRA.DSA BOOTSTRA.SF || exit -1
    fi
    if [ `ls -lA1 | wc -l` -eq 0 ]; then
      cd .. || exit -1
      rmdir META-INF || exit -1
    fi
  fi
}

get_dependency () {
  if [ ! -f $DEPENDENCY_FILE ]; then
    cat <<EOF
Unable to find build "classpath" dependency file:
  $DEPENDENCY_FILE

For example, if we're transforming:
  \$CIP/lib/core.jar
and "core" has compile dependencies upon:
  lib/bootstrap.jar
  lib/util.jar
  sys/log4j.jar
  sys/servlet.jar
  sys/concurrent.jar
then dependency file should contain:
  core.deps = bootstrap, util
  core.jars = log4j, servlet, concurrent
which is parsed into:
  LIB=\
    \$CIP/lib/bootstrap.jar:\$CIP/lib/util.jar:\
    \$CIP/sys/log4j.jar:\$CIP/sys/servlet.jar:\
    \$CIP/sys/concurrent.jar
  javac ... -classpath \$LIB:<etc> ...
EOF
    exit -1
  fi

  # parse file
  RET=`perl -ne\
    'print join(" ", split(/,/, $1)) if (/^\s*'${2}'\s*=\s*(.*)$/);'\
    $DEPENDENCY_FILE`

  eval "$1=\"$RET\""
}

get_classpath () {
  # RFE: couldn't we just use the bootstrapper?

  # get jar dependencies from "default.build"
  get_dependency SEPLIB "${MODULE}\.deps"
  get_dependency SEPSYS "${MODULE}\.jars"

  if [ -z "$SEPLIB" ] && [ -z "$SEPSYS" ]; then
    echo "  zero dependencies: $DEPENDENCY_FILE"
  fi

  LIBDEP=""
  for x in $SEPLIB; do
    if [ -f $CIP/lib/$x.jar ]; then
      LIBDEP="$LIBDEP:$CIP/lib/$x.jar"
    else
      echo "  missing dependency: $CIP/lib/$x.jar"
    fi
  done
  SYSDEP="$CIP/lib/javaiopatch.jar"
  for x in $SEPSYS; do
    if [ -f $CIP/sys/$x.jar ]; then
      SYSDEP="$SYSDEP:$CIP/sys/$x.jar"
    else
      echo "  missing dependency: $CIP/sys/$x.jar"
    fi
  done

  RET="$DIR/$MODULE.jar"
  if [ ! -z $LIBDEP ]; then
    RET="$RET:$LIBDEP"
  fi
  if [ ! -z $SYSDEP ]; then
    RET="$RET:$SYSDEP"
  fi

  eval "$1=\"$RET\""
}

transform () {
  LIB=$1

  echo "  instrumenting"

  CP="$BCEL:$CIP/lib/profiler_transform.jar:$CIP/lib/profiler_impl.jar"
  if [ ! -z $LIB ]; then
    CP="$CP:$LIB"
  fi

  cd $TMP/$MODULE || exit -1
  COMMAND="java \
    -classpath $CP\
    org.cougaar.profiler.transform.ProfileAll\
    old"
  if [ ! -z $VERBOSE ]; then
    echo $COMMAND
  fi
  $COMMAND || exit -1
  if [ ! -d new/old/classes ]; then
    echo "Transform $MODULE failed, missing $TMP/new/old/classes"
    exit -1
  fi
}

transform_jdk () {
  NAME=$1

  if [ $NAME = lang ]; then
    echo "Unable to profile \"java.lang\""
    exit -1
  fi

  if [ -z $FILTERS ]; then
    FILTERS="java/${NAME}/*"
  fi

  restore_jars
  prepare_jdk $NAME
  transform
  create_jars
}

transform_cougaar () {
  restore_jars
  prepare_cougaar
  get_classpath LIB
  transform $LIB
  create_jars
}

# parse "[/foo/]${MODULE}[.jar]"
BASE=`echo $MODULE | perl -ne 'print $2 if (/^(.*\/)?([^\/]*)(\.jar)$/)'`
if [ ! -z $BASE ]; then
  MODULE=$BASE
fi

if [ $MODULE = profiler_impl ] ||
  [ $MODULE = profiler_transform ] ||
  [ $MODULE = bootstrap ]; then
  echo "skipping $MODULE"
  exit 0
fi

echo "transforming $MODULE"

# parse "java${NAME}patch"
NAME=`echo $MODULE | perl -ne 'print $1 if (/^java(.*)patch$/)'`

get_dir DIR $NAME

if [ -z $NAME ]; then
  transform_cougaar
else
  transform_jdk $NAME
fi
